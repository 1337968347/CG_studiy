/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./engine/MV.ts":
/*!**********************!*\
  !*** ./engine/MV.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"vec3\": () => (/* binding */ vec3),\n/* harmony export */   \"mat3\": () => (/* binding */ mat3),\n/* harmony export */   \"mat4\": () => (/* binding */ mat4),\n/* harmony export */   \"quat4\": () => (/* binding */ quat4),\n/* harmony export */   \"vec4\": () => (/* binding */ vec4)\n/* harmony export */ });\n/*\r\n * glMatrix.js - High performance matrix and vector operations for WebGL\r\n * version 0.9.6\r\n */\r\n/*\r\n * Copyright (c) 2011 Brandon Jones\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty. In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n *\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n *\r\n *    1. The origin of this software must not be misrepresented; you must not\r\n *    claim that you wrote the original software. If you use this software\r\n *    in a product, an acknowledgment in the product documentation would be\r\n *    appreciated but is not required.\r\n *\r\n *    2. Altered source versions must be plainly marked as such, and must not\r\n *    be misrepresented as being the original software.\r\n *\r\n *    3. This notice may not be removed or altered from any source\r\n *    distribution.\r\n */\r\n/*\r\n * vec3 - 3 Dimensional Vector\r\n */\r\nconst vec3 = {\r\n    /*\r\n     * vec3.create\r\n     * Creates a new instance of a vec3 using the default array type\r\n     * Any javascript array containing at least 3 numeric elements can serve as a vec3\r\n     *\r\n     * Params:\r\n     * vec - Optional, vec3 containing values to initialize with\r\n     *\r\n     * Returns:\r\n     * New vec3\r\n     */\r\n    create: function (vec) {\r\n        var dest = new Float32Array(3);\r\n        if (vec) {\r\n            dest[0] = vec[0];\r\n            dest[1] = vec[1];\r\n            dest[2] = vec[2];\r\n        }\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.set\r\n     * Copies the values of one vec3 to another\r\n     *\r\n     * Params:\r\n     * vec - vec3 containing values to copy\r\n     * dest - vec3 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest\r\n     */\r\n    set: function (vec, dest) {\r\n        dest[0] = vec[0];\r\n        dest[1] = vec[1];\r\n        dest[2] = vec[2];\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.add\r\n     * Performs a vector addition\r\n     *\r\n     * Params:\r\n     * vec - vec3, first operand\r\n     * vec2 - vec3, second operand\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    add: function (vec, vec2, dest) {\r\n        if (!dest || vec == dest) {\r\n            vec[0] += vec2[0];\r\n            vec[1] += vec2[1];\r\n            vec[2] += vec2[2];\r\n            return vec;\r\n        }\r\n        dest[0] = vec[0] + vec2[0];\r\n        dest[1] = vec[1] + vec2[1];\r\n        dest[2] = vec[2] + vec2[2];\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.subtract\r\n     * Performs a vector subtraction\r\n     *\r\n     * Params:\r\n     * vec - vec3, first operand\r\n     * vec2 - vec3, second operand\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    subtract: function (vec, vec2, dest) {\r\n        if (!dest || vec == dest) {\r\n            vec[0] -= vec2[0];\r\n            vec[1] -= vec2[1];\r\n            vec[2] -= vec2[2];\r\n            return vec;\r\n        }\r\n        dest[0] = vec[0] - vec2[0];\r\n        dest[1] = vec[1] - vec2[1];\r\n        dest[2] = vec[2] - vec2[2];\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.negate\r\n     * Negates the components of a vec3\r\n     *\r\n     * Params:\r\n     * vec - vec3 to negate\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    negate: function (vec, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        dest[0] = -vec[0];\r\n        dest[1] = -vec[1];\r\n        dest[2] = -vec[2];\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.scale\r\n     * Multiplies the components of a vec3 by a scalar value\r\n     *\r\n     * Params:\r\n     * vec - vec3 to scale\r\n     * val - Numeric value to scale by\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    scale: function (vec, val, dest) {\r\n        if (!dest || vec == dest) {\r\n            vec[0] *= val;\r\n            vec[1] *= val;\r\n            vec[2] *= val;\r\n            return vec;\r\n        }\r\n        dest[0] = vec[0] * val;\r\n        dest[1] = vec[1] * val;\r\n        dest[2] = vec[2] * val;\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.normalize\r\n     * Generates a unit vector of the same direction as the provided vec3\r\n     * If vector length is 0, returns [0, 0, 0]\r\n     *\r\n     * Params:\r\n     * vec - vec3 to normalize\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    normalize: function (vec, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        var len = Math.sqrt(x * x + y * y + z * z);\r\n        if (!len) {\r\n            dest[0] = 0;\r\n            dest[1] = 0;\r\n            dest[2] = 0;\r\n            return dest;\r\n        }\r\n        else if (len == 1) {\r\n            dest[0] = x;\r\n            dest[1] = y;\r\n            dest[2] = z;\r\n            return dest;\r\n        }\r\n        len = 1 / len;\r\n        dest[0] = x * len;\r\n        dest[1] = y * len;\r\n        dest[2] = z * len;\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.cross\r\n     * Generates the cross product of two vec3s\r\n     *\r\n     * Params:\r\n     * vec - vec3, first operand\r\n     * vec2 - vec3, second operand\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    cross: function (vec, vec2, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        var x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];\r\n        dest[0] = y * z2 - z * y2;\r\n        dest[1] = z * x2 - x * z2;\r\n        dest[2] = x * y2 - y * x2;\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.length\r\n     * Caclulates the length of a vec3\r\n     *\r\n     * Params:\r\n     * vec - vec3 to calculate length of\r\n     *\r\n     * Returns:\r\n     * Length of vec\r\n     */\r\n    length: function (vec) {\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        return Math.sqrt(x * x + y * y + z * z);\r\n    },\r\n    /*\r\n     * vec3.dot\r\n     * Caclulates the dot product of two vec3s\r\n     *\r\n     * Params:\r\n     * vec - vec3, first operand\r\n     * vec2 - vec3, second operand\r\n     *\r\n     * Returns:\r\n     * Dot product of vec and vec2\r\n     */\r\n    dot: function (vec, vec2) {\r\n        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];\r\n    },\r\n    /*\r\n     * vec3.direction\r\n     * Generates a unit vector pointing from one vector to another\r\n     *\r\n     * Params:\r\n     * vec - origin vec3\r\n     * vec2 - vec3 to point to\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    direction: function (vec, vec2, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        var x = vec[0] - vec2[0];\r\n        var y = vec[1] - vec2[1];\r\n        var z = vec[2] - vec2[2];\r\n        var len = Math.sqrt(x * x + y * y + z * z);\r\n        if (!len) {\r\n            dest[0] = 0;\r\n            dest[1] = 0;\r\n            dest[2] = 0;\r\n            return dest;\r\n        }\r\n        len = 1 / len;\r\n        dest[0] = x * len;\r\n        dest[1] = y * len;\r\n        dest[2] = z * len;\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.lerp\r\n     * Performs a linear interpolation between two vec3\r\n     * 线性插值\r\n     *\r\n     * Params:\r\n     * vec - vec3, first vector\r\n     * vec2 - vec3, second vector\r\n     * lerp - interpolation amount between the two inputs\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    lerp: function (vec, vec2, lerp, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);\r\n        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);\r\n        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec3.str\r\n     * Returns a string representation of a vector\r\n     *\r\n     * Params:\r\n     * vec - vec3 to represent as a string\r\n     *\r\n     * Returns:\r\n     * string representation of vec\r\n     */\r\n    str: function (vec) {\r\n        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';\r\n    },\r\n};\r\n/*\r\n * mat3 - 3x3 Matrix\r\n */\r\nconst mat3 = {\r\n    /*\r\n     * mat3.create\r\n     * Creates a new instance of a mat3 using the default array type\r\n     * Any javascript array containing at least 9 numeric elements can serve as a mat3\r\n     *\r\n     * Params:\r\n     * mat - Optional, mat3 containing values to initialize with\r\n     *\r\n     * Returns:\r\n     * New mat3\r\n     */\r\n    create: function (mat) {\r\n        var dest = new Float32Array(9);\r\n        if (mat) {\r\n            dest[0] = mat[0];\r\n            dest[1] = mat[1];\r\n            dest[2] = mat[2];\r\n            dest[3] = mat[3];\r\n            dest[4] = mat[4];\r\n            dest[5] = mat[5];\r\n            dest[6] = mat[6];\r\n            dest[7] = mat[7];\r\n            dest[8] = mat[8];\r\n        }\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat3.set\r\n     * Copies the values of one mat3 to another\r\n     *\r\n     * Params:\r\n     * mat - mat3 containing values to copy\r\n     * dest - mat3 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest\r\n     */\r\n    set: function (mat, dest) {\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[1];\r\n        dest[2] = mat[2];\r\n        dest[3] = mat[3];\r\n        dest[4] = mat[4];\r\n        dest[5] = mat[5];\r\n        dest[6] = mat[6];\r\n        dest[7] = mat[7];\r\n        dest[8] = mat[8];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat3.identity\r\n     * Sets a mat3 to an identity matrix\r\n     *\r\n     * Params:\r\n     * dest - mat3 to set\r\n     *\r\n     * Returns:\r\n     * dest\r\n     */\r\n    identity: function (dest) {\r\n        dest[0] = 1;\r\n        dest[1] = 0;\r\n        dest[2] = 0;\r\n        dest[3] = 0;\r\n        dest[4] = 1;\r\n        dest[5] = 0;\r\n        dest[6] = 0;\r\n        dest[7] = 0;\r\n        dest[8] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.transpose\r\n     * Transposes a mat3 (flips the values over the diagonal)\r\n     *\r\n     * Params:\r\n     * mat - mat3 to transpose\r\n     * dest - Optional, mat3 receiving transposed values. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest is specified, mat otherwise\r\n     */\r\n    transpose: function (mat, dest) {\r\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n        if (!dest || mat == dest) {\r\n            var a01 = mat[1], a02 = mat[2];\r\n            var a12 = mat[5];\r\n            mat[1] = mat[3];\r\n            mat[2] = mat[6];\r\n            mat[3] = a01;\r\n            mat[5] = mat[7];\r\n            mat[6] = a02;\r\n            mat[7] = a12;\r\n            return mat;\r\n        }\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[3];\r\n        dest[2] = mat[6];\r\n        dest[3] = mat[1];\r\n        dest[4] = mat[4];\r\n        dest[5] = mat[7];\r\n        dest[6] = mat[2];\r\n        dest[7] = mat[5];\r\n        dest[8] = mat[8];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat3.toMat4\r\n     * Copies the elements of a mat3 into the upper 3x3 elements of a mat4\r\n     *\r\n     * Params:\r\n     * mat - mat3 containing values to copy\r\n     * dest - Optional, mat4 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat4 otherwise\r\n     */\r\n    toMat4: function (mat, dest) {\r\n        if (!dest) {\r\n            dest = mat4.create();\r\n        }\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[1];\r\n        dest[2] = mat[2];\r\n        dest[3] = 0;\r\n        dest[4] = mat[3];\r\n        dest[5] = mat[4];\r\n        dest[6] = mat[5];\r\n        dest[7] = 0;\r\n        dest[8] = mat[6];\r\n        dest[9] = mat[7];\r\n        dest[10] = mat[8];\r\n        dest[11] = 0;\r\n        dest[12] = 0;\r\n        dest[13] = 0;\r\n        dest[14] = 0;\r\n        dest[15] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat3.str\r\n     * Returns a string representation of a mat3\r\n     *\r\n     * Params:\r\n     * mat - mat3 to represent as a string\r\n     *\r\n     * Returns:\r\n     * string representation of mat\r\n     */\r\n    str: function (mat) {\r\n        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] + ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] + ', ' + mat[8] + ']';\r\n    },\r\n};\r\n/*\r\n * mat4 - 4x4 Matrix\r\n */\r\nconst mat4 = {\r\n    /*\r\n     * mat4.create\r\n     * Creates a new instance of a mat4 using the default array type\r\n     * Any javascript array containing at least 16 numeric elements can serve as a mat4\r\n     *\r\n     * Params:\r\n     * mat - Optional, mat4 containing values to initialize with\r\n     *\r\n     * Returns:\r\n     * New mat4\r\n     */\r\n    create: function (mat) {\r\n        var dest = new Float32Array(16);\r\n        if (mat) {\r\n            dest[0] = mat[0];\r\n            dest[1] = mat[1];\r\n            dest[2] = mat[2];\r\n            dest[3] = mat[3];\r\n            dest[4] = mat[4];\r\n            dest[5] = mat[5];\r\n            dest[6] = mat[6];\r\n            dest[7] = mat[7];\r\n            dest[8] = mat[8];\r\n            dest[9] = mat[9];\r\n            dest[10] = mat[10];\r\n            dest[11] = mat[11];\r\n            dest[12] = mat[12];\r\n            dest[13] = mat[13];\r\n            dest[14] = mat[14];\r\n            dest[15] = mat[15];\r\n        }\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.set\r\n     * Copies the values of one mat4 to another\r\n     *\r\n     * Params:\r\n     * mat - mat4 containing values to copy\r\n     * dest - mat4 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest\r\n     */\r\n    set: function (mat, dest) {\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[1];\r\n        dest[2] = mat[2];\r\n        dest[3] = mat[3];\r\n        dest[4] = mat[4];\r\n        dest[5] = mat[5];\r\n        dest[6] = mat[6];\r\n        dest[7] = mat[7];\r\n        dest[8] = mat[8];\r\n        dest[9] = mat[9];\r\n        dest[10] = mat[10];\r\n        dest[11] = mat[11];\r\n        dest[12] = mat[12];\r\n        dest[13] = mat[13];\r\n        dest[14] = mat[14];\r\n        dest[15] = mat[15];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.identity\r\n     * Sets a mat4 to an identity matrix\r\n     *\r\n     * Params:\r\n     * dest - mat4 to set\r\n     *\r\n     * Returns:\r\n     * dest\r\n     */\r\n    identity: function (dest) {\r\n        dest[0] = 1;\r\n        dest[1] = 0;\r\n        dest[2] = 0;\r\n        dest[3] = 0;\r\n        dest[4] = 0;\r\n        dest[5] = 1;\r\n        dest[6] = 0;\r\n        dest[7] = 0;\r\n        dest[8] = 0;\r\n        dest[9] = 0;\r\n        dest[10] = 1;\r\n        dest[11] = 0;\r\n        dest[12] = 0;\r\n        dest[13] = 0;\r\n        dest[14] = 0;\r\n        dest[15] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.transpose\r\n     * Transposes a mat4 (flips the values over the diagonal)\r\n     *\r\n     * Params:\r\n     * mat - mat4 to transpose\r\n     * dest - Optional, mat4 receiving transposed values. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest is specified, mat otherwise\r\n     */\r\n    transpose: function (mat, dest) {\r\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n        if (!dest || mat == dest) {\r\n            var a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n            var a12 = mat[6], a13 = mat[7];\r\n            var a23 = mat[11];\r\n            mat[1] = mat[4];\r\n            mat[2] = mat[8];\r\n            mat[3] = mat[12];\r\n            mat[4] = a01;\r\n            mat[6] = mat[9];\r\n            mat[7] = mat[13];\r\n            mat[8] = a02;\r\n            mat[9] = a12;\r\n            mat[11] = mat[14];\r\n            mat[12] = a03;\r\n            mat[13] = a13;\r\n            mat[14] = a23;\r\n            return mat;\r\n        }\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[4];\r\n        dest[2] = mat[8];\r\n        dest[3] = mat[12];\r\n        dest[4] = mat[1];\r\n        dest[5] = mat[5];\r\n        dest[6] = mat[9];\r\n        dest[7] = mat[13];\r\n        dest[8] = mat[2];\r\n        dest[9] = mat[6];\r\n        dest[10] = mat[10];\r\n        dest[11] = mat[14];\r\n        dest[12] = mat[3];\r\n        dest[13] = mat[7];\r\n        dest[14] = mat[11];\r\n        dest[15] = mat[15];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.determinant\r\n     * Calculates the determinant of a mat4\r\n     *\r\n     * Params:\r\n     * mat - mat4 to calculate determinant of\r\n     *\r\n     * Returns:\r\n     * determinant of mat\r\n     */\r\n    determinant: function (mat) {\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];\r\n        return (a30 * a21 * a12 * a03 -\r\n            a20 * a31 * a12 * a03 -\r\n            a30 * a11 * a22 * a03 +\r\n            a10 * a31 * a22 * a03 +\r\n            a20 * a11 * a32 * a03 -\r\n            a10 * a21 * a32 * a03 -\r\n            a30 * a21 * a02 * a13 +\r\n            a20 * a31 * a02 * a13 +\r\n            a30 * a01 * a22 * a13 -\r\n            a00 * a31 * a22 * a13 -\r\n            a20 * a01 * a32 * a13 +\r\n            a00 * a21 * a32 * a13 +\r\n            a30 * a11 * a02 * a23 -\r\n            a10 * a31 * a02 * a23 -\r\n            a30 * a01 * a12 * a23 +\r\n            a00 * a31 * a12 * a23 +\r\n            a10 * a01 * a32 * a23 -\r\n            a00 * a11 * a32 * a23 -\r\n            a20 * a11 * a02 * a33 +\r\n            a10 * a21 * a02 * a33 +\r\n            a20 * a01 * a12 * a33 -\r\n            a00 * a21 * a12 * a33 -\r\n            a10 * a01 * a22 * a33 +\r\n            a00 * a11 * a22 * a33);\r\n    },\r\n    /*\r\n     * mat4.inverse\r\n     * Calculates the inverse matrix of a mat4\r\n     *\r\n     * Params:\r\n     * mat - mat4 to calculate inverse of\r\n     * dest - Optional, mat4 receiving inverse matrix. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest is specified, mat otherwise\r\n     */\r\n    inverse: function (mat, dest) {\r\n        if (!dest) {\r\n            dest = mat;\r\n        }\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n        // Calculate the determinant (inlined to avoid double-caching)\r\n        var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\r\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\r\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\r\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\r\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\r\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\r\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\r\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\r\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\r\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\r\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\r\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\r\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\r\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\r\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\r\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\r\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.toRotationMat\r\n     * Copies the upper 3x3 elements of a mat4 into another mat4\r\n     *\r\n     * Params:\r\n     * mat - mat4 containing values to copy\r\n     * dest - Optional, mat4 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest is specified, a new mat4 otherwise\r\n     */\r\n    toRotationMat: function (mat, dest) {\r\n        if (!dest) {\r\n            dest = mat4.create();\r\n        }\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[1];\r\n        dest[2] = mat[2];\r\n        dest[3] = mat[3];\r\n        dest[4] = mat[4];\r\n        dest[5] = mat[5];\r\n        dest[6] = mat[6];\r\n        dest[7] = mat[7];\r\n        dest[8] = mat[8];\r\n        dest[9] = mat[9];\r\n        dest[10] = mat[10];\r\n        dest[11] = mat[11];\r\n        dest[12] = 0;\r\n        dest[13] = 0;\r\n        dest[14] = 0;\r\n        dest[15] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.toMat3\r\n     * Copies the upper 3x3 elements of a mat4 into a mat3\r\n     *\r\n     * Params:\r\n     * mat - mat4 containing values to copy\r\n     * dest - Optional, mat3 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest is specified, a new mat3 otherwise\r\n     */\r\n    toMat3: function (mat, dest) {\r\n        if (!dest) {\r\n            dest = mat3.create();\r\n        }\r\n        dest[0] = mat[0];\r\n        dest[1] = mat[1];\r\n        dest[2] = mat[2];\r\n        dest[3] = mat[4];\r\n        dest[4] = mat[5];\r\n        dest[5] = mat[6];\r\n        dest[6] = mat[8];\r\n        dest[7] = mat[9];\r\n        dest[8] = mat[10];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.toInverseMat3\r\n     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3\r\n     * The resulting matrix is useful for calculating transformed normals\r\n     *\r\n     * Params:\r\n     * mat - mat4 containing values to invert and copy\r\n     * dest - Optional, mat3 receiving values\r\n     *\r\n     * Returns:\r\n     * dest is specified, a new mat3 otherwise\r\n     */\r\n    toInverseMat3: function (mat, dest) {\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10];\r\n        var b01 = a22 * a11 - a12 * a21;\r\n        var b11 = -a22 * a10 + a12 * a20;\r\n        var b21 = a21 * a10 - a11 * a20;\r\n        var d = a00 * b01 + a01 * b11 + a02 * b21;\r\n        if (!d) {\r\n            return null;\r\n        }\r\n        var id = 1 / d;\r\n        if (!dest) {\r\n            dest = mat3.create();\r\n        }\r\n        dest[0] = b01 * id;\r\n        dest[1] = (-a22 * a01 + a02 * a21) * id;\r\n        dest[2] = (a12 * a01 - a02 * a11) * id;\r\n        dest[3] = b11 * id;\r\n        dest[4] = (a22 * a00 - a02 * a20) * id;\r\n        dest[5] = (-a12 * a00 + a02 * a10) * id;\r\n        dest[6] = b21 * id;\r\n        dest[7] = (-a21 * a00 + a01 * a20) * id;\r\n        dest[8] = (a11 * a00 - a01 * a10) * id;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.multiply\r\n     * Performs a matrix multiplication\r\n     *\r\n     * Params:\r\n     * mat - mat4, first operand\r\n     * mat2 - mat4, second operand\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    multiply: function (mat, mat2, dest) {\r\n        if (!dest) {\r\n            dest = mat;\r\n        }\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];\r\n        var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];\r\n        var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];\r\n        var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];\r\n        var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];\r\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\r\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\r\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\r\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\r\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\r\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\r\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\r\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\r\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\r\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\r\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\r\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\r\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\r\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\r\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\r\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.multiplyVec3\r\n     * Transforms a vec3 with the given matrix\r\n     * 4th vector component is implicitly '1'\r\n     *\r\n     * Params:\r\n     * mat - mat4 to transform the vector with\r\n     * vec - vec3 to transform\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    multiplyVec3: function (mat, vec, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];\r\n        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];\r\n        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.multiplyVec4\r\n     * Transforms a vec4 with the given matrix\r\n     *\r\n     * Params:\r\n     * mat - mat4 to transform the vector with\r\n     * vec - vec4 to transform\r\n     * dest - Optional, vec4 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    multiplyVec4: function (mat, vec, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];\r\n        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;\r\n        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;\r\n        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;\r\n        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.translate\r\n     * Translates a matrix by the given vector\r\n     *\r\n     * Params:\r\n     * mat - mat4 to translate\r\n     * vec - vec3 specifying the translation\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    translate: function (mat, vec, dest) {\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        if (!dest || mat == dest) {\r\n            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];\r\n            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];\r\n            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];\r\n            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];\r\n            return mat;\r\n        }\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        dest[0] = a00;\r\n        dest[1] = a01;\r\n        dest[2] = a02;\r\n        dest[3] = a03;\r\n        dest[4] = a10;\r\n        dest[5] = a11;\r\n        dest[6] = a12;\r\n        dest[7] = a13;\r\n        dest[8] = a20;\r\n        dest[9] = a21;\r\n        dest[10] = a22;\r\n        dest[11] = a23;\r\n        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];\r\n        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];\r\n        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];\r\n        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.scale\r\n     * Scales a matrix by the given vector\r\n     *\r\n     * Params:\r\n     * mat - mat4 to scale\r\n     * vec - vec3 specifying the scale for each axis\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    scale: function (mat, vec, dest) {\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        if (!dest || mat == dest) {\r\n            mat[0] *= x;\r\n            mat[1] *= x;\r\n            mat[2] *= x;\r\n            mat[3] *= x;\r\n            mat[4] *= y;\r\n            mat[5] *= y;\r\n            mat[6] *= y;\r\n            mat[7] *= y;\r\n            mat[8] *= z;\r\n            mat[9] *= z;\r\n            mat[10] *= z;\r\n            mat[11] *= z;\r\n            return mat;\r\n        }\r\n        dest[0] = mat[0] * x;\r\n        dest[1] = mat[1] * x;\r\n        dest[2] = mat[2] * x;\r\n        dest[3] = mat[3] * x;\r\n        dest[4] = mat[4] * y;\r\n        dest[5] = mat[5] * y;\r\n        dest[6] = mat[6] * y;\r\n        dest[7] = mat[7] * y;\r\n        dest[8] = mat[8] * z;\r\n        dest[9] = mat[9] * z;\r\n        dest[10] = mat[10] * z;\r\n        dest[11] = mat[11] * z;\r\n        dest[12] = mat[12];\r\n        dest[13] = mat[13];\r\n        dest[14] = mat[14];\r\n        dest[15] = mat[15];\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.rotate\r\n     * Rotates a matrix by the given angle around the specified axis\r\n     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance\r\n     *\r\n     * Params:\r\n     * mat - mat4 to rotate\r\n     * angle - angle (in radians) to rotate\r\n     * axis - vec3 representing the axis to rotate around\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    rotate: function (mat, angle, axis, dest) {\r\n        var x = axis[0], y = axis[1], z = axis[2];\r\n        var len = Math.sqrt(x * x + y * y + z * z);\r\n        if (!len) {\r\n            return null;\r\n        }\r\n        if (len != 1) {\r\n            len = 1 / len;\r\n            x *= len;\r\n            y *= len;\r\n            z *= len;\r\n        }\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        var t = 1 - c;\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        // 旋转矩阵\r\n        // Construct the elements of the rotation matrix\r\n        var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s;\r\n        var b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s;\r\n        var b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;\r\n        if (!dest) {\r\n            dest = mat;\r\n        }\r\n        else if (mat != dest) {\r\n            // If the source and destination differ, copy the unchanged last row\r\n            dest[12] = mat[12];\r\n            dest[13] = mat[13];\r\n            dest[14] = mat[14];\r\n            dest[15] = mat[15];\r\n        }\r\n        // Perform rotation-specific matrix multiplication\r\n        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.rotateX\r\n     * Rotates a matrix by the given angle around the X axis\r\n     *\r\n     * Params:\r\n     * mat - mat4 to rotate\r\n     * angle - angle (in radians) to rotate\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    rotateX: function (mat, angle, dest) {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        if (!dest) {\r\n            dest = mat;\r\n        }\r\n        else if (mat != dest) {\r\n            // If the source and destination differ, copy the unchanged rows\r\n            dest[0] = mat[0];\r\n            dest[1] = mat[1];\r\n            dest[2] = mat[2];\r\n            dest[3] = mat[3];\r\n            dest[12] = mat[12];\r\n            dest[13] = mat[13];\r\n            dest[14] = mat[14];\r\n            dest[15] = mat[15];\r\n        }\r\n        // Perform axis-specific matrix multiplication\r\n        dest[4] = a10 * c + a20 * s;\r\n        dest[5] = a11 * c + a21 * s;\r\n        dest[6] = a12 * c + a22 * s;\r\n        dest[7] = a13 * c + a23 * s;\r\n        dest[8] = a10 * -s + a20 * c;\r\n        dest[9] = a11 * -s + a21 * c;\r\n        dest[10] = a12 * -s + a22 * c;\r\n        dest[11] = a13 * -s + a23 * c;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.rotateY\r\n     * Rotates a matrix by the given angle around the Y axis\r\n     *\r\n     * Params:\r\n     * mat - mat4 to rotate\r\n     * angle - angle (in radians) to rotate\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    rotateY: function (mat, angle, dest) {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];\r\n        if (!dest) {\r\n            dest = mat;\r\n        }\r\n        else if (mat != dest) {\r\n            // If the source and destination differ, copy the unchanged rows\r\n            dest[4] = mat[4];\r\n            dest[5] = mat[5];\r\n            dest[6] = mat[6];\r\n            dest[7] = mat[7];\r\n            dest[12] = mat[12];\r\n            dest[13] = mat[13];\r\n            dest[14] = mat[14];\r\n            dest[15] = mat[15];\r\n        }\r\n        // Perform axis-specific matrix multiplication\r\n        dest[0] = a00 * c + a20 * -s;\r\n        dest[1] = a01 * c + a21 * -s;\r\n        dest[2] = a02 * c + a22 * -s;\r\n        dest[3] = a03 * c + a23 * -s;\r\n        dest[8] = a00 * s + a20 * c;\r\n        dest[9] = a01 * s + a21 * c;\r\n        dest[10] = a02 * s + a22 * c;\r\n        dest[11] = a03 * s + a23 * c;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.rotateZ\r\n     * Rotates a matrix by the given angle around the Z axis\r\n     *\r\n     * Params:\r\n     * mat - mat4 to rotate\r\n     * angle - angle (in radians) to rotate\r\n     * dest - Optional, mat4 receiving operation result. If not specified result is written to mat\r\n     *\r\n     * Returns:\r\n     * dest if specified, mat otherwise\r\n     */\r\n    rotateZ: function (mat, angle, dest) {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        // Cache the matrix values (makes for huge speed increases!)\r\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];\r\n        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];\r\n        if (!dest) {\r\n            dest = mat;\r\n        }\r\n        else if (mat != dest) {\r\n            // If the source and destination differ, copy the unchanged last row\r\n            dest[8] = mat[8];\r\n            dest[9] = mat[9];\r\n            dest[10] = mat[10];\r\n            dest[11] = mat[11];\r\n            dest[12] = mat[12];\r\n            dest[13] = mat[13];\r\n            dest[14] = mat[14];\r\n            dest[15] = mat[15];\r\n        }\r\n        // Perform axis-specific matrix multiplication\r\n        dest[0] = a00 * c + a10 * s;\r\n        dest[1] = a01 * c + a11 * s;\r\n        dest[2] = a02 * c + a12 * s;\r\n        dest[3] = a03 * c + a13 * s;\r\n        dest[4] = a00 * -s + a10 * c;\r\n        dest[5] = a01 * -s + a11 * c;\r\n        dest[6] = a02 * -s + a12 * c;\r\n        dest[7] = a03 * -s + a13 * c;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.frustum\r\n     * Generates a frustum matrix with the given bounds\r\n     *\r\n     * Params:\r\n     * left, right - scalar, left and right bounds of the frustum\r\n     * bottom, top - scalar, bottom and top bounds of the frustum\r\n     * near, far - scalar, near and far bounds of the frustum\r\n     * dest - Optional, mat4 frustum matrix will be written into\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat4 otherwise\r\n     */\r\n    frustum: function (left, right, bottom, top, near, far, dest) {\r\n        if (!dest) {\r\n            dest = mat4.create();\r\n        }\r\n        var rl = right - left;\r\n        var tb = top - bottom;\r\n        var fn = far - near;\r\n        dest[0] = (near * 2) / rl;\r\n        dest[1] = 0;\r\n        dest[2] = 0;\r\n        dest[3] = 0;\r\n        dest[4] = 0;\r\n        dest[5] = (near * 2) / tb;\r\n        dest[6] = 0;\r\n        dest[7] = 0;\r\n        dest[8] = (right + left) / rl;\r\n        dest[9] = (top + bottom) / tb;\r\n        dest[10] = -(far + near) / fn;\r\n        dest[11] = -1;\r\n        dest[12] = 0;\r\n        dest[13] = 0;\r\n        dest[14] = -(far * near * 2) / fn;\r\n        dest[15] = 0;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.perspective\r\n     * Generates a perspective projection matrix with the given bounds\r\n     *\r\n     * Params:\r\n     * fovy - scalar, vertical field of view\r\n     * aspect - scalar, aspect ratio. typically viewport width/height\r\n     * near, far - scalar, near and far bounds of the frustum\r\n     * dest - Optional, mat4 frustum matrix will be written into\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat4 otherwise\r\n     */\r\n    perspective: function (fovy, aspect, near, far, dest) {\r\n        var top = near * Math.tan((fovy * Math.PI) / 360.0);\r\n        var right = top * aspect;\r\n        return mat4.frustum(-right, right, -top, top, near, far, dest);\r\n    },\r\n    /*\r\n     * mat4.ortho 正交矩阵\r\n     * Generates a orthogonal projection matrix with the given bounds\r\n     *\r\n     * Params:\r\n     * left, right - scalar, left and right bounds of the frustum\r\n     * bottom, top - scalar, bottom and top bounds of the frustum\r\n     * near, far - scalar, near and far bounds of the frustum\r\n     * dest - Optional, mat4 frustum matrix will be written into\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat4 otherwise\r\n     */\r\n    ortho: function (left, right, bottom, top, near, far, dest) {\r\n        if (!dest) {\r\n            dest = mat4.create();\r\n        }\r\n        var rl = right - left;\r\n        var tb = top - bottom;\r\n        var fn = far - near;\r\n        dest[0] = 2 / rl;\r\n        dest[1] = 0;\r\n        dest[2] = 0;\r\n        dest[3] = 0;\r\n        dest[4] = 0;\r\n        dest[5] = 2 / tb;\r\n        dest[6] = 0;\r\n        dest[7] = 0;\r\n        dest[8] = 0;\r\n        dest[9] = 0;\r\n        dest[10] = -2 / fn;\r\n        dest[11] = 0;\r\n        dest[12] = -(left + right) / rl;\r\n        dest[13] = -(top + bottom) / tb;\r\n        dest[14] = -(far + near) / fn;\r\n        dest[15] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.ortho\r\n     * Generates a look-at matrix with the given eye position, focal point, and up axis\r\n     *\r\n     * Params:\r\n     * eye - vec3, position of the viewer\r\n     * center - vec3, point the viewer is looking at\r\n     * up - vec3 pointing \"up\"\r\n     * dest - Optional, mat4 frustum matrix will be written into\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat4 otherwise\r\n     */\r\n    lookAt: function (eye, center, up, dest) {\r\n        if (!dest) {\r\n            dest = mat4.create();\r\n        }\r\n        var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];\r\n        if (eyex == centerx && eyey == centery && eyez == centerz) {\r\n            return mat4.identity(dest);\r\n        }\r\n        var z0, z1, z2, x0, x1, x2, y0, y1, y2, len;\r\n        //vec3.direction(eye, center, z);\r\n        z0 = eyex - center[0];\r\n        z1 = eyey - center[1];\r\n        z2 = eyez - center[2];\r\n        // normalize (no check needed for 0 because of early return)\r\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n        z0 *= len;\r\n        z1 *= len;\r\n        z2 *= len;\r\n        //vec3.normalize(vec3.cross(up, z, x));\r\n        x0 = upy * z2 - upz * z1;\r\n        x1 = upz * z0 - upx * z2;\r\n        x2 = upx * z1 - upy * z0;\r\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n        if (!len) {\r\n            x0 = 0;\r\n            x1 = 0;\r\n            x2 = 0;\r\n        }\r\n        else {\r\n            len = 1 / len;\r\n            x0 *= len;\r\n            x1 *= len;\r\n            x2 *= len;\r\n        }\r\n        //vec3.normalize(vec3.cross(z, x, y));\r\n        y0 = z1 * x2 - z2 * x1;\r\n        y1 = z2 * x0 - z0 * x2;\r\n        y2 = z0 * x1 - z1 * x0;\r\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n        if (!len) {\r\n            y0 = 0;\r\n            y1 = 0;\r\n            y2 = 0;\r\n        }\r\n        else {\r\n            len = 1 / len;\r\n            y0 *= len;\r\n            y1 *= len;\r\n            y2 *= len;\r\n        }\r\n        dest[0] = x0;\r\n        dest[1] = y0;\r\n        dest[2] = z0;\r\n        dest[3] = 0;\r\n        dest[4] = x1;\r\n        dest[5] = y1;\r\n        dest[6] = z1;\r\n        dest[7] = 0;\r\n        dest[8] = x2;\r\n        dest[9] = y2;\r\n        dest[10] = z2;\r\n        dest[11] = 0;\r\n        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n        dest[15] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * mat4.str\r\n     * Returns a string representation of a mat4\r\n     *\r\n     * Params:\r\n     * mat - mat4 to represent as a string\r\n     *\r\n     * Returns:\r\n     * string representation of mat\r\n     */\r\n    str: function (mat) {\r\n        return ('[' +\r\n            mat[0] +\r\n            ', ' +\r\n            mat[1] +\r\n            ', ' +\r\n            mat[2] +\r\n            ', ' +\r\n            mat[3] +\r\n            ', ' +\r\n            mat[4] +\r\n            ', ' +\r\n            mat[5] +\r\n            ', ' +\r\n            mat[6] +\r\n            ', ' +\r\n            mat[7] +\r\n            ', ' +\r\n            mat[8] +\r\n            ', ' +\r\n            mat[9] +\r\n            ', ' +\r\n            mat[10] +\r\n            ', ' +\r\n            mat[11] +\r\n            ', ' +\r\n            mat[12] +\r\n            ', ' +\r\n            mat[13] +\r\n            ', ' +\r\n            mat[14] +\r\n            ', ' +\r\n            mat[15] +\r\n            ']');\r\n    },\r\n};\r\n/*\r\n * quat4 - Quaternions 四元数\r\n */\r\nconst quat4 = {\r\n    /*\r\n     * quat4.create\r\n     * Creates a new instance of a quat4 using the default array type\r\n     * Any javascript array containing at least 4 numeric elements can serve as a quat4\r\n     *\r\n     * Params:\r\n     * quat - Optional, quat4 containing values to initialize with\r\n     *\r\n     * Returns:\r\n     * New quat4\r\n     */\r\n    create: function (quat) {\r\n        var dest = new Float32Array(4);\r\n        if (quat) {\r\n            dest[0] = quat[0];\r\n            dest[1] = quat[1];\r\n            dest[2] = quat[2];\r\n            dest[3] = quat[3];\r\n        }\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.set\r\n     * Copies the values of one quat4 to another\r\n     *\r\n     * Params:\r\n     * quat - quat4 containing values to copy\r\n     * dest - quat4 receiving copied values\r\n     *\r\n     * Returns:\r\n     * dest\r\n     */\r\n    set: function (quat, dest) {\r\n        dest[0] = quat[0];\r\n        dest[1] = quat[1];\r\n        dest[2] = quat[2];\r\n        dest[3] = quat[3];\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.calculateW\r\n     * Calculates the W component of a quat4 from the X, Y, and Z components.\r\n     * Assumes that quaternion is 1 unit in length.\r\n     * Any existing W component will be ignored.\r\n     *\r\n     * Params:\r\n     * quat - quat4 to calculate W component of\r\n     * dest - Optional, quat4 receiving calculated values. If not specified result is written to quat\r\n     *\r\n     * Returns:\r\n     * dest if specified, quat otherwise\r\n     */\r\n    calculateW: function (quat, dest) {\r\n        var x = quat[0], y = quat[1], z = quat[2];\r\n        if (!dest || quat == dest) {\r\n            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\r\n            return quat;\r\n        }\r\n        dest[0] = x;\r\n        dest[1] = y;\r\n        dest[2] = z;\r\n        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.inverse\r\n     * Calculates the inverse of a quat4\r\n     *\r\n     * Params:\r\n     * quat - quat4 to calculate inverse of\r\n     * dest - Optional, quat4 receiving inverse values. If not specified result is written to quat\r\n     *\r\n     * Returns:\r\n     * dest if specified, quat otherwise\r\n     */\r\n    inverse: function (quat, dest) {\r\n        if (!dest || quat == dest) {\r\n            quat[0] *= -1;\r\n            quat[1] *= -1;\r\n            quat[2] *= -1;\r\n            return quat;\r\n        }\r\n        dest[0] = -quat[0];\r\n        dest[1] = -quat[1];\r\n        dest[2] = -quat[2];\r\n        dest[3] = quat[3];\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.length\r\n     * Calculates the length of a quat4\r\n     *\r\n     * Params:\r\n     * quat - quat4 to calculate length of\r\n     *\r\n     * Returns:\r\n     * Length of quat\r\n     */\r\n    length: function (quat) {\r\n        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n    /*\r\n     * quat4.normalize\r\n     * Generates a unit quaternion of the same direction as the provided quat4\r\n     * If quaternion length is 0, returns [0, 0, 0, 0]\r\n     *\r\n     * Params:\r\n     * quat - quat4 to normalize\r\n     * dest - Optional, quat4 receiving operation result. If not specified result is written to quat\r\n     *\r\n     * Returns:\r\n     * dest if specified, quat otherwise\r\n     */\r\n    normalize: function (quat, dest) {\r\n        if (!dest) {\r\n            dest = quat;\r\n        }\r\n        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];\r\n        var len = Math.sqrt(x * x + y * y + z * z + w * w);\r\n        if (len == 0) {\r\n            dest[0] = 0;\r\n            dest[1] = 0;\r\n            dest[2] = 0;\r\n            dest[3] = 0;\r\n            return dest;\r\n        }\r\n        len = 1 / len;\r\n        dest[0] = x * len;\r\n        dest[1] = y * len;\r\n        dest[2] = z * len;\r\n        dest[3] = w * len;\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.multiply\r\n     * Performs a quaternion multiplication\r\n     *\r\n     * Params:\r\n     * quat - quat4, first operand\r\n     * quat2 - quat4, second operand\r\n     * dest - Optional, quat4 receiving operation result. If not specified result is written to quat\r\n     *\r\n     * Returns:\r\n     * dest if specified, quat otherwise\r\n     */\r\n    multiply: function (quat, quat2, dest) {\r\n        if (!dest) {\r\n            dest = quat;\r\n        }\r\n        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3];\r\n        var qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];\r\n        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.multiplyVec3\r\n     * Transforms a vec3 with the given quaternion\r\n     *\r\n     * Params:\r\n     * quat - quat4 to transform the vector with\r\n     * vec - vec3 to transform\r\n     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    multiplyVec3: function (quat, vec, dest) {\r\n        if (!dest) {\r\n            dest = vec;\r\n        }\r\n        var x = vec[0], y = vec[1], z = vec[2];\r\n        var qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3];\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n        // calculate result * inverse quat\r\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.toMat3\r\n     * Calculates a 3x3 matrix from the given quat4\r\n     *\r\n     * Params:\r\n     * quat - quat4 to create matrix from\r\n     * dest - Optional, mat3 receiving operation result\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat3 otherwise\r\n     */\r\n    toMat3: function (quat, dest) {\r\n        if (!dest) {\r\n            dest = mat3.create();\r\n        }\r\n        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n        dest[0] = 1 - (yy + zz);\r\n        dest[1] = xy - wz;\r\n        dest[2] = xz + wy;\r\n        dest[3] = xy + wz;\r\n        dest[4] = 1 - (xx + zz);\r\n        dest[5] = yz - wx;\r\n        dest[6] = xz - wy;\r\n        dest[7] = yz + wx;\r\n        dest[8] = 1 - (xx + yy);\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.toMat4\r\n     * Calculates a 4x4 matrix from the given quat4\r\n     *\r\n     * Params:\r\n     * quat - quat4 to create matrix from\r\n     * dest - Optional, mat4 receiving operation result\r\n     *\r\n     * Returns:\r\n     * dest if specified, a new mat4 otherwise\r\n     */\r\n    toMat4: function (quat, dest) {\r\n        if (!dest) {\r\n            dest = mat4.create();\r\n        }\r\n        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n        dest[0] = 1 - (yy + zz);\r\n        dest[1] = xy - wz;\r\n        dest[2] = xz + wy;\r\n        dest[3] = 0;\r\n        dest[4] = xy + wz;\r\n        dest[5] = 1 - (xx + zz);\r\n        dest[6] = yz - wx;\r\n        dest[7] = 0;\r\n        dest[8] = xz - wy;\r\n        dest[9] = yz + wx;\r\n        dest[10] = 1 - (xx + yy);\r\n        dest[11] = 0;\r\n        dest[12] = 0;\r\n        dest[13] = 0;\r\n        dest[14] = 0;\r\n        dest[15] = 1;\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.slerp\r\n     * Performs a spherical linear interpolation between two quat4\r\n     *\r\n     * Params:\r\n     * quat - quat4, first quaternion\r\n     * quat2 - quat4, second quaternion\r\n     * slerp - interpolation amount between the two inputs\r\n     * dest - Optional, quat4 receiving operation result. If not specified result is written to quat\r\n     *\r\n     * Returns:\r\n     * dest if specified, quat otherwise\r\n     */\r\n    slerp: function (quat, quat2, slerp, dest) {\r\n        if (!dest) {\r\n            dest = quat;\r\n        }\r\n        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3];\r\n        if (Math.abs(cosHalfTheta) >= 1.0) {\r\n            if (dest != quat) {\r\n                dest[0] = quat[0];\r\n                dest[1] = quat[1];\r\n                dest[2] = quat[2];\r\n                dest[3] = quat[3];\r\n            }\r\n            return dest;\r\n        }\r\n        var halfTheta = Math.acos(cosHalfTheta);\r\n        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\r\n        if (Math.abs(sinHalfTheta) < 0.001) {\r\n            dest[0] = quat[0] * 0.5 + quat2[0] * 0.5;\r\n            dest[1] = quat[1] * 0.5 + quat2[1] * 0.5;\r\n            dest[2] = quat[2] * 0.5 + quat2[2] * 0.5;\r\n            dest[3] = quat[3] * 0.5 + quat2[3] * 0.5;\r\n            return dest;\r\n        }\r\n        var ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;\r\n        var ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;\r\n        dest[0] = quat[0] * ratioA + quat2[0] * ratioB;\r\n        dest[1] = quat[1] * ratioA + quat2[1] * ratioB;\r\n        dest[2] = quat[2] * ratioA + quat2[2] * ratioB;\r\n        dest[3] = quat[3] * ratioA + quat2[3] * ratioB;\r\n        return dest;\r\n    },\r\n    /*\r\n     * quat4.str\r\n     * Returns a string representation of a quaternion\r\n     *\r\n     * Params:\r\n     * quat - quat4 to represent as a string\r\n     *\r\n     * Returns:\r\n     * string representation of quat\r\n     */\r\n    str: function (quat) {\r\n        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';\r\n    },\r\n};\r\nconst vec4 = {\r\n    /*\r\n     * vec4.create\r\n     * Creates a new instance of a vec3 using the default array type\r\n     * Any javascript array containing at least 3 numeric elements can serve as a vec3\r\n     *\r\n     * Params:\r\n     * vec - Optional, vec3 or 4 containing values to initialize with\r\n     * w - Optional w component used to initialize the vec4, required when a vec3 is provided\r\n     *\r\n     * Returns  :\r\n     * New vec4\r\n     */\r\n    create: function (vec, w) {\r\n        var dest = new Float32Array(4);\r\n        if (vec) {\r\n            dest[0] = vec[0];\r\n            dest[1] = vec[1];\r\n            dest[2] = vec[2];\r\n            if (vec.length > 3) {\r\n                dest[3] = vec[3];\r\n            }\r\n            else {\r\n                dest[3] = w;\r\n            }\r\n        }\r\n        return dest;\r\n    },\r\n    /*\r\n     * vec4.scale\r\n     * Multiplies the components of a vec4 by a scalar value\r\n     *\r\n     * Params:\r\n     * vec - vec4 to scale\r\n     * val - Numeric value to scale by\r\n     * dest - Optional, vec4 receiving operation result. If not specified result is written to vec\r\n     *\r\n     * Returns:\r\n     * dest if specified, vec otherwise\r\n     */\r\n    scale: function (vec, val, dest) {\r\n        if (!dest || vec == dest) {\r\n            vec[0] *= val;\r\n            vec[1] *= val;\r\n            vec[2] *= val;\r\n            vec[3] *= val;\r\n            return vec;\r\n        }\r\n        dest[0] = vec[0] * val;\r\n        dest[1] = vec[1] * val;\r\n        dest[2] = vec[2] * val;\r\n        dest[3] = vec[3] * val;\r\n        return dest;\r\n    },\r\n};\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/MV.ts?");

/***/ }),

/***/ "./engine/glUtils.ts":
/*!***************************!*\
  !*** ./engine/glUtils.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mat4\": () => (/* binding */ Mat4),\n/* harmony export */   \"Mat3\": () => (/* binding */ Mat3),\n/* harmony export */   \"Vec3\": () => (/* binding */ Vec3),\n/* harmony export */   \"Vec4\": () => (/* binding */ Vec4),\n/* harmony export */   \"Int\": () => (/* binding */ Int),\n/* harmony export */   \"uniform\": () => (/* binding */ uniform),\n/* harmony export */   \"Texture2D\": () => (/* binding */ Texture2D),\n/* harmony export */   \"FrameBufferObject\": () => (/* binding */ FrameBufferObject),\n/* harmony export */   \"BufferObject\": () => (/* binding */ BufferObject),\n/* harmony export */   \"VertexBufferObject\": () => (/* binding */ VertexBufferObject),\n/* harmony export */   \"getImageData\": () => (/* binding */ getImageData),\n/* harmony export */   \"sampleHeight\": () => (/* binding */ sampleHeight),\n/* harmony export */   \"setCanvasFullScreen\": () => (/* binding */ setCanvasFullScreen)\n/* harmony export */ });\nconst createGlValue = (set, value) => {\r\n    const setValue = (value) => {\r\n        const uniform = (location) => {\r\n            set(location, value);\r\n        };\r\n        return { uniform, value };\r\n    };\r\n    return setValue(value);\r\n};\r\nconst Mat4 = (value) => {\r\n    return createGlValue((location, gl) => {\r\n        gl.uniformMatrix4fv(location, false, value);\r\n    }, value);\r\n};\r\nconst Mat3 = (value) => {\r\n    return createGlValue((location, gl) => {\r\n        gl.uniformMatrix3fv(location, false, value);\r\n    }, value);\r\n};\r\nconst Vec3 = (value) => {\r\n    return createGlValue((location, gl) => {\r\n        gl.uniform3fv(location, value);\r\n    }, value);\r\n};\r\nconst Vec4 = (value) => {\r\n    return createGlValue((location, gl) => {\r\n        gl.uniform4fv(location, value);\r\n    }, value);\r\n};\r\nconst Int = (value) => {\r\n    return createGlValue((location, gl) => {\r\n        gl.uniform1i(location, value);\r\n    }, value);\r\n};\r\nconst uniform = {\r\n    Mat4,\r\n    Mat3,\r\n    Vec3,\r\n    Vec4,\r\n    Int,\r\n};\r\nclass Texture2D {\r\n    constructor(image, gl) {\r\n        this.unit = -1;\r\n        this.image = image;\r\n        this.gl = gl;\r\n        this.texture = this.gl.createTexture();\r\n        this.bindTexture();\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    bindTexture(unit) {\r\n        if (unit !== undefined) {\r\n            this.gl.activeTexture(this.gl.TEXTURE0 + unit);\r\n            this.unit = unit;\r\n        }\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\r\n    }\r\n    unbindTexture() {\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.unit);\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\r\n    }\r\n    uniform(location) {\r\n        this.gl.uniform1i(location, this.unit);\r\n    }\r\n}\r\nclass FrameBufferObject {\r\n    constructor(gl, width, height, format) {\r\n        this.unit = -1;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.gl = gl;\r\n        // FBO 对帧缓存进行操作\r\n        this.frameBuffer = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);\r\n        this.texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        // 创建一个空的纹理\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, format || gl.UNSIGNED_BYTE, null);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        // 存储数据，例如图像，或者可以是渲染操作的源或目标。\r\n        this.depth = gl.createRenderbuffer();\r\n        gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);\r\n        // 创建并初始化渲染缓冲区对象的数据存储。\r\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\r\n        // 将纹理对象关联到FBO\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    }\r\n    bind() {\r\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.frameBuffer);\r\n        this.gl.viewport(0, 0, this.width, this.height);\r\n    }\r\n    unbind() {\r\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\r\n    }\r\n    bindTexture(unit) {\r\n        if (unit !== undefined) {\r\n            this.gl.activeTexture(this.gl.TEXTURE0 + unit);\r\n            this.unit = unit;\r\n        }\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\r\n    }\r\n    unbindTexture() {\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.unit);\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\r\n    }\r\n    uniform(location) {\r\n        this.gl.uniform1i(location, this.unit);\r\n    }\r\n}\r\n/**\r\n * 创建一个存储对象。可以在场景图遍历的过程中动态bind\r\n */\r\nclass BufferObject {\r\n    constructor(vertexData, gl) {\r\n        this.gl = gl;\r\n        this.buffer = this.gl.createBuffer();\r\n        this.bind();\r\n        this.length = vertexData.length;\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexData, this.gl.STATIC_DRAW);\r\n        this.unbind();\r\n    }\r\n    bind() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\r\n    }\r\n    unbind() {\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n    }\r\n}\r\nclass VertexBufferObject extends BufferObject {\r\n    constructor(vertexData, gl) {\r\n        super(vertexData, gl);\r\n    }\r\n    drawTriangles() {\r\n        this.gl.drawArrays(this.gl.TRIANGLES, 0, this.length / 3);\r\n    }\r\n}\r\n// 获取图片的RGBA数组\r\nconst getImageData = (imageEl) => {\r\n    const canvasEl = document.createElement(\"canvas\");\r\n    const ctx = canvasEl.getContext(\"2d\");\r\n    canvasEl.width = imageEl.width;\r\n    canvasEl.height = imageEl.height;\r\n    ctx.drawImage(imageEl, 0, 0);\r\n    return ctx.getImageData(0, 0, imageEl.width, imageEl.height);\r\n};\r\n// 获取图片指定纹理地址的高度\r\nconst sampleHeight = (imgData, u, v) => {\r\n    // ~~ 符号是向下取整\r\n    if (u < 0 || u > 1 || v < 0 || v > 1)\r\n        return 0.0;\r\n    var x = ~~(imgData.width * u), y = ~~(imgData.height * v), i = (y * imgData.width + x) * 4 + 3;\r\n    return imgData.data[i] / 255;\r\n};\r\nconst setCanvasFullScreen = (canvas, scene) => {\r\n    const onResize = () => {\r\n        canvas.width = scene.viewport.width = window.innerWidth;\r\n        canvas.height = scene.viewport.height = window.innerHeight;\r\n    };\r\n    window.addEventListener(\"resize\", onResize, false);\r\n    onResize();\r\n};\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/glUtils.ts?");

/***/ }),

/***/ "./engine/loader.ts":
/*!**************************!*\
  !*** ./engine/loader.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Loader)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass Loader {\r\n    constructor(rootPath) {\r\n        this.resources = {};\r\n        this.pendingStatus = {\r\n            total: 0,\r\n            pending: 0,\r\n            failed: 0,\r\n        };\r\n        this.loadImage = (src) => {\r\n            const imageEl = document.createElement(\"img\");\r\n            imageEl.src = this.rootPath + src;\r\n            imageEl.onload = () => {\r\n                this.success(src, imageEl);\r\n            };\r\n            imageEl.onerror = () => {\r\n                this.error(src, imageEl);\r\n            };\r\n        };\r\n        this.loadJSON = (src) => {\r\n            fetch(this.rootPath + src)\r\n                .then((res) => __awaiter(this, void 0, void 0, function* () {\r\n                return res.json();\r\n            }))\r\n                .then((json) => this.success(src, json))\r\n                .catch((e) => {\r\n                this.error(src, e);\r\n            });\r\n        };\r\n        this.loadData = (src) => {\r\n            fetch(this.rootPath + src)\r\n                .then((res) => __awaiter(this, void 0, void 0, function* () {\r\n                return res.text();\r\n            }))\r\n                .then((text) => {\r\n                this.success(src, text);\r\n            })\r\n                .catch((e) => {\r\n                this.error(src, e);\r\n            });\r\n        };\r\n        this.success = (src, data) => {\r\n            this.resources[src] = data;\r\n            this.pendingStatus.pending--;\r\n            this.pendingStatus.pending === 0 && this.onRendy && this.onRendy();\r\n        };\r\n        this.error = (src, err) => {\r\n            this.pendingStatus.pending--;\r\n            this.pendingStatus.failed++;\r\n            this.resources[src] = null;\r\n            if (typeof err !== \"string\") {\r\n                err.path = src;\r\n            }\r\n            throw err;\r\n        };\r\n        this.rootPath = rootPath;\r\n    }\r\n    load(resources) {\r\n        for (let i = 0; i < resources.length; i++) {\r\n            const path = resources[i];\r\n            if (path in resources) {\r\n                continue;\r\n            }\r\n            this.pendingStatus.pending++;\r\n            this.pendingStatus.total++;\r\n            if (/\\.(jpe?g|gif|png)$/.test(path)) {\r\n                this.loadImage(path);\r\n                continue;\r\n            }\r\n            if (/\\.json$/.test(path)) {\r\n                this.loadJSON(path);\r\n                continue;\r\n            }\r\n            this.loadData(path);\r\n        }\r\n        setTimeout(() => {\r\n            this.pendingStatus.pending === 0 && this.onRendy && this.onRendy();\r\n        }, 1);\r\n    }\r\n    setOnRendy(onRendy) {\r\n        this.onRendy = onRendy;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/loader.ts?");

/***/ }),

/***/ "./engine/mesh.ts":
/*!************************!*\
  !*** ./engine/mesh.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"gird\": () => (/* binding */ gird),\n/* harmony export */   \"wireFrame\": () => (/* binding */ wireFrame),\n/* harmony export */   \"screen_quad\": () => (/* binding */ screen_quad),\n/* harmony export */   \"cute\": () => (/* binding */ cute),\n/* harmony export */   \"makePerlinNoise\": () => (/* binding */ makePerlinNoise),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// 采样\r\nconst gird = (size) => {\r\n    const buffer = new Float32Array(size * size * 6 * 3);\r\n    let i = 0;\r\n    for (var y = 0; y < size; y++) {\r\n        for (var x = 0; x < size; x++) {\r\n            buffer[i++] = x / size;\r\n            buffer[i++] = 0;\r\n            buffer[i++] = y / size;\r\n            buffer[i++] = x / size;\r\n            buffer[i++] = 0;\r\n            buffer[i++] = (y + 1) / size;\r\n            buffer[i++] = (x + 1) / size;\r\n            buffer[i++] = 0;\r\n            buffer[i++] = (y + 1) / size;\r\n            buffer[i++] = x / size;\r\n            buffer[i++] = 0;\r\n            buffer[i++] = y / size;\r\n            buffer[i++] = (x + 1) / size;\r\n            buffer[i++] = 0;\r\n            buffer[i++] = (y + 1) / size;\r\n            buffer[i++] = (x + 1) / size;\r\n            buffer[i++] = 0;\r\n            buffer[i++] = y / size;\r\n        }\r\n    }\r\n    return buffer;\r\n};\r\nconst wireFrame = (input) => {\r\n    const output = new Float32Array(input.length * 2);\r\n    const triangles = input.length / 9;\r\n    for (var t = 0; t < triangles; t++) {\r\n        for (var v1 = 0; v1 < 3; v1++) {\r\n            var v2 = (v1 + 1) % 3;\r\n            for (var i = 0; i < 3; i++) {\r\n                output[t * 18 + v1 * 3 + i] = input[t * 9 + v1 * 3 + i];\r\n                output[t * 18 + v1 * 3 + 9 + i] = input[t * 9 + v2 * 3 + i];\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n};\r\n// 屏幕上一个正方形\r\nconst screen_quad = () => {\r\n    return new Float32Array([\r\n        -1, 1, 0, -1, -1, 0, 1, -1, 0,\r\n        -1, 1, 0, 1, -1, 0, 1, 1, 0,\r\n    ]);\r\n};\r\nconst cute = (scale) => {\r\n    scale = scale || 1;\r\n    return new Float32Array([\r\n        // back\r\n        scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        // front\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        // left\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        // right\r\n        scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        // top\r\n        scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        // bottom\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n        -scale,\r\n        scale,\r\n        -scale,\r\n        scale,\r\n        scale,\r\n        -scale,\r\n        -scale,\r\n    ]);\r\n};\r\nconst makePerlinNoise = (seed) => {\r\n    const perm = new Array(512);\r\n    const gradP = new Array(512);\r\n    const dot = (v1, v2) => {\r\n        return v1[0] * v2[0] + v1[1] * v2[1];\r\n    };\r\n    const p = [\r\n        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,\r\n        36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,\r\n        234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\r\n        88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\r\n        134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\r\n        230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,\r\n        1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,\r\n        116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,\r\n        124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,\r\n        47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\r\n        154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,\r\n        108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,\r\n        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,\r\n        239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\r\n        50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,\r\n        141, 128, 195, 78, 66, 215, 61, 156, 180,\r\n    ];\r\n    const grad3 = [\r\n        [1, 1, 0],\r\n        [-1, 1, 0],\r\n        [1, -1, 0],\r\n        [-1, -1, 0],\r\n        [1, 0, 1],\r\n        [-1, 0, 1],\r\n        [1, 0, -1],\r\n        [-1, 0, -1],\r\n        [0, 1, 1],\r\n        [0, -1, 1],\r\n        [0, 1, -1],\r\n        [0, -1, -1],\r\n    ];\r\n    const fade = (t) => {\r\n        return t * t * t * (t * (t * 6 - 15) + 10);\r\n    };\r\n    const lerp = (u, v, a) => {\r\n        return u * (1 - a) + v * a;\r\n    };\r\n    const init = () => {\r\n        if (seed > 0 && seed < 1) {\r\n            // Scale the seed out\r\n            seed *= 65536;\r\n        }\r\n        seed = Math.floor(seed);\r\n        if (seed < 256) {\r\n            seed |= seed << 8;\r\n        }\r\n        for (let i = 0; i < 256; i++) {\r\n            let v;\r\n            if (i & 1) {\r\n                v = p[i] ^ (seed & 255);\r\n            }\r\n            else {\r\n                v = p[i] ^ ((seed >> 8) & 255);\r\n            }\r\n            perm[i] = perm[i + 256] = v;\r\n            gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n        }\r\n    };\r\n    init();\r\n    /**\r\n     *\r\n     * @param {*} u [0,1)\r\n     * @param {*} v [0,1)\r\n     */\r\n    const getUVPixel = (u, v) => {\r\n        // 当前晶格左上角的坐标\r\n        const xInt = ~~u;\r\n        const yInt = ~~v;\r\n        // 小数部分\r\n        let u1 = u - xInt;\r\n        let v1 = v - yInt;\r\n        const g00 = dot(gradP[xInt + perm[yInt]], [u1, v1]);\r\n        const g01 = dot(gradP[xInt + perm[yInt + 1]], [u1, v1 - 1]);\r\n        const g10 = dot(gradP[xInt + 1 + perm[yInt]], [u1 - 1, v1]);\r\n        const g11 = dot(gradP[xInt + 1 + perm[yInt + 1]], [u1 - 1, v1 - 1]);\r\n        const u2 = fade(u1);\r\n        const v2 = fade(v1);\r\n        return lerp(lerp(g00, g10, u2), lerp(g01, g11, u2), v2);\r\n    };\r\n    return { getUVPixel };\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ gird, cute, wireFrame, screen_quad, makePerlinNoise });\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/mesh.ts?");

/***/ }),

/***/ "./engine/renderer.ts":
/*!****************************!*\
  !*** ./engine/renderer.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CameraController\": () => (/* binding */ CameraController),\n/* harmony export */   \"default\": () => (/* binding */ InputHandler),\n/* harmony export */   \"Clock\": () => (/* binding */ Clock),\n/* harmony export */   \"WebGLRenderer\": () => (/* binding */ WebGLRenderer)\n/* harmony export */ });\n/* harmony import */ var _MV__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MV */ \"./engine/MV.ts\");\n\r\nconst KEYNAME = {\r\n    32: \"SPACE\",\r\n    13: \"ENTER\",\r\n    9: \"TAB\",\r\n    8: \"BACKSPACE\",\r\n    16: \"SHIFT\",\r\n    17: \"CTRL\",\r\n    18: \"ALT\",\r\n    20: \"CAPS_LOCK\",\r\n    144: \"NUM_LOCK\",\r\n    145: \"SCROLL_LOCK\",\r\n    37: \"LEFT\",\r\n    38: \"UP\",\r\n    39: \"RIGHT\",\r\n    40: \"DOWN\",\r\n    33: \"PAGE_UP\",\r\n    34: \"PAGE_DOWN\",\r\n    36: \"HOME\",\r\n    35: \"END\",\r\n    45: \"INSERT\",\r\n    46: \"DELETE\",\r\n    27: \"ESCAPE\",\r\n    19: \"PAUSE\",\r\n};\r\nconst clamp = (a, b, c) => {\r\n    return a < b ? b : a > c ? c : a;\r\n};\r\nconst pointerCoord = (ev) => {\r\n    // get X coordinates for either a mouse click\r\n    // or a touch depending on the given event\r\n    if (ev) {\r\n        const changedTouches = ev.changedTouches;\r\n        if (changedTouches && changedTouches.length > 0) {\r\n            const touch = changedTouches[0];\r\n            return { x: touch.clientX, y: touch.clientY };\r\n        }\r\n        if (ev.pageX !== undefined) {\r\n            return { x: ev.pageX, y: ev.pageY };\r\n        }\r\n    }\r\n    return { x: 0, y: 0 };\r\n};\r\nclass CameraController {\r\n    constructor(input) {\r\n        this.input = input;\r\n    }\r\n    tick(camera) {\r\n        const { x, y } = this.input.getOffsetFromElementCenter();\r\n        camera.y += x * 0.00008;\r\n        camera.x += y * 0.00008;\r\n        const inverseRotation = camera.getInverseRotation();\r\n        const direction = _MV__WEBPACK_IMPORTED_MODULE_0__.vec3.create();\r\n        if (this.input.keys.W) {\r\n            direction[2] = -1;\r\n        }\r\n        else if (this.input.keys.S) {\r\n            direction[2] = 1;\r\n        }\r\n        if (this.input.keys.A) {\r\n            direction[0] = -1;\r\n        }\r\n        else if (this.input.keys.D) {\r\n            direction[0] = 1;\r\n        }\r\n        _MV__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(direction);\r\n        // 先获取方向, 然后在这个方向上平移\r\n        _MV__WEBPACK_IMPORTED_MODULE_0__.mat4.multiplyVec3(inverseRotation, direction);\r\n        _MV__WEBPACK_IMPORTED_MODULE_0__.vec3.add(camera.position, direction);\r\n    }\r\n}\r\nclass InputHandler {\r\n    constructor(element) {\r\n        this.keys = {};\r\n        this.offset = { x: 0, y: 0 };\r\n        this.mouse = { down: false, x: 0, y: 0 };\r\n        this.onClick = undefined;\r\n        this.onKeyUp = undefined;\r\n        this.onKeyDown = undefined;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.hasFocus = true;\r\n        this.element = undefined;\r\n        this.focus = () => {\r\n            if (!this.hasFocus) {\r\n                this.hasFocus = true;\r\n                this.reset();\r\n            }\r\n        };\r\n        this.blur = () => {\r\n            this.hasFocus = false;\r\n            this.reset();\r\n        };\r\n        this.mouseMove = (pageX, pageY) => {\r\n            if (!this.mouse.down)\r\n                return;\r\n            this.mouse.x = clamp(pageX - this.offset.x, 0, this.element.width);\r\n            this.mouse.y = clamp(pageY - this.offset.y, 0, this.element.height);\r\n        };\r\n        this.mouseDown = (pageX, pageY) => {\r\n            this.mouse.down = true;\r\n            this.mouse.x = clamp(pageX - this.offset.x, 0, this.element.width);\r\n            this.mouse.y = clamp(pageY - this.offset.y, 0, this.element.height);\r\n        };\r\n        this.mouseUp = () => {\r\n            this.mouse.down = false;\r\n            if (this.hasFocus && this.onClick) {\r\n                this.onClick(this.mouse.x, this.mouse.y);\r\n            }\r\n        };\r\n        this.keyDown = (key) => {\r\n            const keyName = this.getKeyName(key);\r\n            const wasKeyDown = this.keys[keyName];\r\n            this.keys[keyName] = true;\r\n            if (this.onKeyDown && !wasKeyDown) {\r\n                this.onKeyDown(keyName);\r\n            }\r\n            return this.hasFocus;\r\n        };\r\n        this.keyUp = (key) => {\r\n            var name = this.getKeyName(key);\r\n            this.keys[name] = false;\r\n            if (this.onKeyUp) {\r\n                this.onKeyUp(name);\r\n            }\r\n            return this.hasFocus;\r\n        };\r\n        this.reset = () => {\r\n            this.keys = {};\r\n            for (let i = 65; i < 128; i++) {\r\n                this.keys[String.fromCharCode(i)] = false;\r\n            }\r\n            for (let i in KEYNAME) {\r\n                this.keys[KEYNAME[i]] = false;\r\n            }\r\n            this.mouse = { down: false, x: 0, y: 0 };\r\n        };\r\n        this.getKeyName = (key) => {\r\n            return KEYNAME[key] || String.fromCharCode(key);\r\n        };\r\n        this.element = element;\r\n        this.bind(element);\r\n        this.reset();\r\n    }\r\n    bind(element) {\r\n        if (!element)\r\n            return;\r\n        this.element = element;\r\n        const elementRect = element.getBoundingClientRect();\r\n        this.offset = { x: elementRect.left, y: elementRect.top };\r\n        // 绑定监听事件\r\n        document.onkeydown = (e) => this.keyDown(e.keyCode);\r\n        document.onkeyup = (e) => this.keyUp(e.keyCode);\r\n        window.onclick = (e) => {\r\n            if (e.target === element) {\r\n                focus();\r\n            }\r\n            else {\r\n                blur();\r\n            }\r\n        };\r\n        this.element.onmousedown = (e) => {\r\n            const { x, y } = pointerCoord(e);\r\n            this.mouseDown(x, y);\r\n        };\r\n        this.element.ontouchstart = (e) => {\r\n            const { x, y } = pointerCoord(e);\r\n            this.mouseDown(x, y);\r\n        };\r\n        document.ontouchmove = (e) => {\r\n            const { x, y } = pointerCoord(e);\r\n            this.mouseMove(x, y);\r\n        };\r\n        document.onmousemove = (e) => {\r\n            const { x, y } = pointerCoord(e);\r\n            this.mouseMove(x, y);\r\n        };\r\n        document.ontouchend = this.mouseUp;\r\n        document.ontouchcancel = this.mouseUp;\r\n        document.onmouseup = this.mouseUp;\r\n    }\r\n    // 获取鼠标点击点距离元素中心的距离\r\n    getOffsetFromElementCenter() {\r\n        if (!this.element) {\r\n            return { x: 0, y: 0 };\r\n        }\r\n        if (this.mouse.down) {\r\n            return {\r\n                x: this.mouse.x - this.element.width * 0.5,\r\n                y: this.mouse.y - this.element.height * 0.5,\r\n            };\r\n        }\r\n        return { x: 0, y: 0 };\r\n    }\r\n}\r\nclass Clock {\r\n    constructor() {\r\n        this.isRunning = false;\r\n        this.timerId = null;\r\n    }\r\n    start() {\r\n        if (this.isRunning)\r\n            return;\r\n        this.isRunning = true;\r\n        this.now = new Date().getTime();\r\n        const timerLoop = (func) => {\r\n            this.timerId = setTimeout(func, 16);\r\n        };\r\n        // raf\r\n        this.loopFunc = window.requestAnimationFrame.bind(window) || timerLoop;\r\n        const animationFunc = (time) => {\r\n            if (this.isRunning) {\r\n                this.tick(time);\r\n                this.loopFunc(animationFunc);\r\n            }\r\n        };\r\n        // start\r\n        this.loopFunc(animationFunc);\r\n    }\r\n    stop() {\r\n        this.isRunning = false;\r\n        if (this.timerId) {\r\n            clearTimeout(this.timerId);\r\n            this.timerId = null;\r\n        }\r\n    }\r\n    tick(tickTime) {\r\n        this.onTick && this.onTick((tickTime - this.now) / 1000);\r\n        this.now = tickTime;\r\n    }\r\n    setAnimationLoop(onTick) {\r\n        this.onTick = onTick;\r\n    }\r\n}\r\nclass WebGLRenderer {\r\n    constructor() {\r\n        this.clock = new Clock();\r\n        this.domElement = document.createElement(\"canvas\");\r\n        this.gl = this.domElement.getContext(\"webgl\");\r\n        this.inputHandler = new InputHandler(this.domElement);\r\n        this.cameraController = new CameraController(this.inputHandler);\r\n    }\r\n    start() {\r\n        this.clock.start();\r\n    }\r\n    stop() {\r\n        if (this.clock.isRunning) {\r\n            this.clock.stop();\r\n        }\r\n    }\r\n    getGLRenderContext() {\r\n        return this.gl;\r\n    }\r\n    setAnimationLoop(aniLoop) {\r\n        this.clock.setAnimationLoop(aniLoop);\r\n    }\r\n    render(scene, camera) {\r\n        this.cameraController.tick(camera);\r\n        camera.use(scene);\r\n        scene.draw(camera, this.gl);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/renderer.ts?");

/***/ }),

/***/ "./engine/scene.ts":
/*!*************************!*\
  !*** ./engine/scene.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"Graph\": () => (/* binding */ Graph),\n/* harmony export */   \"RenderTarget\": () => (/* binding */ RenderTarget),\n/* harmony export */   \"Material\": () => (/* binding */ Material),\n/* harmony export */   \"Camera\": () => (/* binding */ Camera),\n/* harmony export */   \"SimpleMesh\": () => (/* binding */ SimpleMesh),\n/* harmony export */   \"Transform\": () => (/* binding */ Transform),\n/* harmony export */   \"Mirror\": () => (/* binding */ Mirror),\n/* harmony export */   \"CameraFixTransform\": () => (/* binding */ CameraFixTransform),\n/* harmony export */   \"Uniforms\": () => (/* binding */ Uniforms),\n/* harmony export */   \"PostProcess\": () => (/* binding */ PostProcess),\n/* harmony export */   \"Skybox\": () => (/* binding */ Skybox)\n/* harmony export */ });\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mesh */ \"./engine/mesh.ts\");\n/* harmony import */ var _MV__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MV */ \"./engine/MV.ts\");\n/* harmony import */ var _glUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glUtils */ \"./engine/glUtils.ts\");\n\r\n\r\n\r\nclass Node {\r\n    constructor(childrenP = []) {\r\n        this.children = [];\r\n        this.children = childrenP;\r\n    }\r\n    visit(scene, camera, gl) {\r\n        this.enter(scene, camera, gl);\r\n        for (let i = 0; i < this.children.length; i++) {\r\n            this.children[i].visit(scene, camera, gl);\r\n        }\r\n        this.exit(scene, camera, gl);\r\n    }\r\n    // overwrite\r\n    exit(_scene, _camera, gl) {\r\n        // console.log(scene);\r\n    }\r\n    append(child) {\r\n        this.children.push(child);\r\n    }\r\n    // overwrite\r\n    enter(_scene, _camera, gl) {\r\n        // console.log(scene);\r\n    }\r\n}\r\nclass Graph {\r\n    constructor() {\r\n        this.uniforms = {};\r\n        this.shaders = [];\r\n        this.textureUnit = 0;\r\n        this.viewport = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 640,\r\n            height: 480,\r\n        };\r\n        this.root = new Node();\r\n    }\r\n    append(node) {\r\n        this.root.append(node);\r\n    }\r\n    draw(camera, gl) {\r\n        gl.viewport(this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height);\r\n        gl.clearColor(0, 0, 0, 1);\r\n        gl.clearDepth(1);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        this.root.visit(this, camera, gl);\r\n    }\r\n    pushUniforms() {\r\n        this.uniforms = Object.create(this.uniforms);\r\n    }\r\n    popUniforms() {\r\n        this.uniforms = Object.getPrototypeOf(this.uniforms);\r\n    }\r\n    pushTextura() {\r\n        return this.textureUnit++;\r\n    }\r\n    popTextura() {\r\n        this.textureUnit--;\r\n    }\r\n    pushShader(shader) {\r\n        this.shaders.push(shader);\r\n    }\r\n    popShader() {\r\n        this.shaders.pop();\r\n    }\r\n    getShader() {\r\n        return this.shaders[this.shaders.length - 1];\r\n    }\r\n}\r\n// 渲染场景到FrameBufferObject上\r\nclass RenderTarget extends Node {\r\n    constructor(fbo, children) {\r\n        super();\r\n        this.children = [];\r\n        this.fbo = fbo;\r\n        this.children = children;\r\n    }\r\n    enter(scene, _camera, gl) {\r\n        this.fbo.bind();\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    exit(scene, _camera, gl) {\r\n        this.fbo.unbind();\r\n        gl.viewport(scene.viewport.x, scene.viewport.y, scene.viewport.width, scene.viewport.height);\r\n    }\r\n}\r\nclass Material extends Node {\r\n    constructor(shader, uniforms, children) {\r\n        super();\r\n        this.children = [];\r\n        this.shader = shader;\r\n        this.uniforms = uniforms;\r\n        this.children = children;\r\n    }\r\n    enter(scene) {\r\n        scene.pushShader(this.shader);\r\n        this.shader.use();\r\n        Uniforms.prototype.enter.call(this, scene);\r\n    }\r\n    exit(scene) {\r\n        scene.popShader();\r\n        Uniforms.prototype.exit.call(this, scene);\r\n    }\r\n}\r\nclass Camera {\r\n    constructor() {\r\n        this.x = 0.0;\r\n        this.y = 0.0;\r\n        this.near = 0.5;\r\n        this.far = 5000;\r\n        this.fov = 50;\r\n        this.position = _MV__WEBPACK_IMPORTED_MODULE_1__.vec3.create([0, 0, 0]);\r\n    }\r\n    use(scene) {\r\n        scene.pushUniforms();\r\n        const position = new Float32Array(this.position);\r\n        const project = this.getProjection();\r\n        const wordView = this.getWorldView();\r\n        const mvp = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.multiply(project, wordView, mvp);\r\n        scene.uniforms.projection = _glUtils__WEBPACK_IMPORTED_MODULE_2__.uniform.Mat4(mvp);\r\n        scene.uniforms.eye = _glUtils__WEBPACK_IMPORTED_MODULE_2__.uniform.Vec3(position);\r\n        scene.popUniforms();\r\n    }\r\n    setProjection(near, far) {\r\n        this.near = near;\r\n        this.far = far;\r\n    }\r\n    project(point) {\r\n        const mvp = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.multiply(this.getProjection(), this.getWorldView(), mvp);\r\n        const projected = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.multiplyVec4(mvp, point, _MV__WEBPACK_IMPORTED_MODULE_1__.vec4.create());\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.vec4.scale(projected, 1 / projected[3]);\r\n        return projected;\r\n    }\r\n    getInverseRotation() {\r\n        return _MV__WEBPACK_IMPORTED_MODULE_1__.mat3.toMat4(_MV__WEBPACK_IMPORTED_MODULE_1__.mat4.toInverseMat3(this.getWorldView()));\r\n    }\r\n    // project\r\n    getProjection() {\r\n        return _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.perspective(this.fov, 1, this.near, this.far);\r\n    }\r\n    // ModelView\r\n    getWorldView() {\r\n        const position = new Float32Array(this.position);\r\n        // 先平移到标架原点， 然后再旋转\r\n        const matrix = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.identity(_MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create());\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.rotateX(matrix, this.x);\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.rotateY(matrix, this.y);\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.translate(matrix, _MV__WEBPACK_IMPORTED_MODULE_1__.vec3.negate(position, _MV__WEBPACK_IMPORTED_MODULE_1__.vec3.create()));\r\n        return matrix;\r\n    }\r\n}\r\nclass SimpleMesh extends Node {\r\n    constructor(BufferGeometry) {\r\n        super();\r\n        this.bufferGeometry = BufferGeometry;\r\n    }\r\n    visit(scene, _camera, gl) {\r\n        const shader = scene.getShader();\r\n        shader.uniforms(scene.uniforms);\r\n        for (const name of Object.keys(this.bufferGeometry)) {\r\n            const bufferObject = this.bufferGeometry[name];\r\n            bufferObject.bind();\r\n            const location = shader.getAttribLocation(name);\r\n            const stride = 0;\r\n            const offset = 0;\r\n            const normalized = false;\r\n            gl.vertexAttribPointer(location, 3, gl.FLOAT, normalized, stride, offset);\r\n            gl.enableVertexAttribArray(location);\r\n            if (bufferObject instanceof _glUtils__WEBPACK_IMPORTED_MODULE_2__.VertexBufferObject) {\r\n                bufferObject.drawTriangles();\r\n            }\r\n        }\r\n        for (const name of Object.keys(this.bufferGeometry)) {\r\n            const bufferObject = this.bufferGeometry[name];\r\n            bufferObject.unbind();\r\n        }\r\n    }\r\n}\r\nclass Transform extends Node {\r\n    constructor(children) {\r\n        super();\r\n        this.children = [];\r\n        this.wordMatrix = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\r\n        this.aux = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\r\n        this.children = children;\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.identity(this.wordMatrix);\r\n    }\r\n    enter(scene, _camera, _gl) {\r\n        scene.pushUniforms();\r\n        if (scene.uniforms.modelTransform) {\r\n            _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.multiply(scene.uniforms.modelTransform.value, this.wordMatrix, this.aux);\r\n            scene.uniforms.modelTransform = _glUtils__WEBPACK_IMPORTED_MODULE_2__.uniform.Mat4(this.aux);\r\n        }\r\n        else {\r\n            scene.uniforms.modelTransform = _glUtils__WEBPACK_IMPORTED_MODULE_2__.uniform.Mat4(this.wordMatrix);\r\n        }\r\n    }\r\n    exit(scene, _camera, _gl) {\r\n        scene.popUniforms();\r\n    }\r\n}\r\nclass Mirror extends Transform {\r\n    constructor(children) {\r\n        super(children);\r\n    }\r\n    enter(scene, _camera, gl) {\r\n        gl.cullFace(gl.FRONT);\r\n        super.enter.call(this, scene);\r\n    }\r\n    exit(scene, _camera, gl) {\r\n        gl.cullFace(gl.BACK);\r\n        super.exit.call(this, scene);\r\n    }\r\n}\r\nclass CameraFixTransform extends Node {\r\n    constructor(children) {\r\n        super(children);\r\n        this.wordMatrix = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\r\n        this.children = children;\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.identity(this.wordMatrix);\r\n    }\r\n    enter(scene, camera) {\r\n        scene.pushUniforms();\r\n        // 相机标架\r\n        const aux = _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.create();\r\n        _MV__WEBPACK_IMPORTED_MODULE_1__.mat4.multiply(_MV__WEBPACK_IMPORTED_MODULE_1__.mat4.inverse(camera.getWorldView()), this.wordMatrix, aux);\r\n        scene.uniforms.modelTransform = _glUtils__WEBPACK_IMPORTED_MODULE_2__.uniform.Mat4(aux);\r\n    }\r\n    exit(scene) {\r\n        scene.popUniforms();\r\n    }\r\n}\r\nclass Uniforms extends Node {\r\n    constructor(uniforms, children) {\r\n        super();\r\n        this.uniforms = uniforms;\r\n        this.children = children;\r\n    }\r\n    enter(scene) {\r\n        scene.pushUniforms();\r\n        for (let uniform in this.uniforms) {\r\n            const value = this.uniforms[uniform];\r\n            if (value instanceof _glUtils__WEBPACK_IMPORTED_MODULE_2__.Texture2D || value instanceof _glUtils__WEBPACK_IMPORTED_MODULE_2__.FrameBufferObject) {\r\n                value.bindTexture(scene.pushTextura());\r\n            }\r\n            // 把this.uniform 绑定到Scene的uniform属性上去\r\n            scene.uniforms[uniform] = value;\r\n        }\r\n    }\r\n    exit(scene) {\r\n        for (let uniform in this.uniforms) {\r\n            const value = this.uniforms[uniform];\r\n            if (value instanceof _glUtils__WEBPACK_IMPORTED_MODULE_2__.Texture2D || value instanceof _glUtils__WEBPACK_IMPORTED_MODULE_2__.FrameBufferObject) {\r\n                value.unbindTexture();\r\n                scene.popTextura();\r\n            }\r\n        }\r\n        scene.popUniforms();\r\n    }\r\n}\r\nclass PostProcess extends Node {\r\n    constructor(shader, uniforms, gl) {\r\n        super();\r\n        const screenVbo = new _glUtils__WEBPACK_IMPORTED_MODULE_2__.VertexBufferObject(_mesh__WEBPACK_IMPORTED_MODULE_0__.screen_quad(), gl);\r\n        const mesh = new SimpleMesh({ position: screenVbo });\r\n        const material = new Material(shader, uniforms, [mesh]);\r\n        this.children = [material];\r\n    }\r\n}\r\nclass Skybox extends Node {\r\n    constructor(shader, uniforms, gl) {\r\n        super();\r\n        const skyVbo = new _glUtils__WEBPACK_IMPORTED_MODULE_2__.VertexBufferObject(_mesh__WEBPACK_IMPORTED_MODULE_0__.cute(), gl);\r\n        const mesh = new SimpleMesh({ position: skyVbo });\r\n        const material = new Material(shader, uniforms, [mesh]);\r\n        this.children = [material];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/scene.ts?");

/***/ }),

/***/ "./engine/shader.ts":
/*!**************************!*\
  !*** ./engine/shader.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shader\": () => (/* binding */ Shader),\n/* harmony export */   \"ShaderManager\": () => (/* binding */ ShaderManager)\n/* harmony export */ });\n/**\r\n * 创建一个Shader\r\n * @param gl\r\n * @param shaderType\r\n * @param source\r\n * @returns\r\n */\r\nconst makeShader = (gl, shaderType, source) => {\r\n    const shader = gl.createShader(shaderType);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        console.warn(gl.getShaderInfoLog(shader), shaderType, source);\r\n        throw 'Compiler exception: \"' + gl.getShaderInfoLog(shader) + '\"';\r\n    }\r\n    return shader;\r\n};\r\n/**\r\n * 创建一个WebGLProgram\r\n * @param gl\r\n * @param vertexSource\r\n * @param fragmentSource\r\n * @returns\r\n */\r\nconst makeProgram = (gl, vertexSource, fragmentSource) => {\r\n    const vertexShader = makeShader(gl, gl.VERTEX_SHADER, vertexSource);\r\n    const fragmentShader = makeShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        throw \"Linker exception: \" + gl.getProgramInfoLog(program);\r\n    }\r\n    return program;\r\n};\r\n/**\r\n * 创建一个shader\r\n * @param gl\r\n * @param vertexSource\r\n * @param fragmentSource\r\n * @returns\r\n */\r\nclass Shader {\r\n    constructor(gl, vertexSource, fragmentSource) {\r\n        this.uniformLocations = {};\r\n        this.gl = gl;\r\n        this.program = makeProgram(this.gl, vertexSource, fragmentSource);\r\n    }\r\n    use() {\r\n        this.gl.useProgram(this.program);\r\n    }\r\n    uniforms(values) {\r\n        for (let name in values) {\r\n            const value = values[name];\r\n            let location;\r\n            if (this.uniformLocations[name] !== undefined) {\r\n                location = this.uniformLocations[name];\r\n            }\r\n            else {\r\n                location = this.gl.getUniformLocation(this.program, name);\r\n                this.uniformLocations[name] = location;\r\n            }\r\n            // 着色器中没有用到这个变量\r\n            if (location === null) {\r\n                continue;\r\n            }\r\n            if (typeof value === \"number\") {\r\n                this.gl.uniform1f(location, value);\r\n            }\r\n            else {\r\n                value.uniform(location, this.gl);\r\n            }\r\n        }\r\n    }\r\n    getAttribLocation(name) {\r\n        const location = this.gl.getAttribLocation(this.program, name);\r\n        if (location < 0)\r\n            throw \"attribute not found\";\r\n        return location;\r\n    }\r\n}\r\nclass ShaderManager {\r\n    constructor(resources, gl) {\r\n        this.shaders = {};\r\n        this.importExpression = /\\/\\/\\/\\s*import \"([^\"]+)\"/g;\r\n        this.resources = resources;\r\n        this.gl = gl;\r\n    }\r\n    get(vertex, frag) {\r\n        if (!frag) {\r\n            frag = vertex + \".frag\";\r\n            vertex = vertex + \".vert\";\r\n        }\r\n        const key = `${vertex}-${frag}`;\r\n        if (!(key in this.resources)) {\r\n            this.shaders[key] = new Shader(this.gl, this.getSource(vertex), this.getSource(frag));\r\n        }\r\n        return this.shaders[key];\r\n    }\r\n    getSource(shaderPath) {\r\n        const name = this._getSourceName(shaderPath);\r\n        const path = name;\r\n        const shaderSourceStr = this.resources[path];\r\n        if (shaderSourceStr == undefined) {\r\n            throw new Error(`cant found ${shaderPath} Source`);\r\n        }\r\n        return shaderSourceStr.replace(this.importExpression, (_, name) => {\r\n            return this.getSource(name);\r\n        });\r\n    }\r\n    _getSourceName(name) {\r\n        const nameArr = name.split(\"/\");\r\n        return nameArr[nameArr.length - 1];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./engine/shader.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _engine_scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/scene */ \"./engine/scene.ts\");\n/* harmony import */ var _engine_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../engine/mesh */ \"./engine/mesh.ts\");\n/* harmony import */ var _engine_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../engine/renderer */ \"./engine/renderer.ts\");\n/* harmony import */ var _engine_glUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../engine/glUtils */ \"./engine/glUtils.ts\");\n/* harmony import */ var _engine_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../engine/loader */ \"./engine/loader.ts\");\n/* harmony import */ var _engine_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../engine/shader */ \"./engine/shader.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nlet camera;\r\nlet scene;\r\nlet renderer = new _engine_renderer__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer();\r\nlet material;\r\nlet mesh;\r\nlet loader;\r\nlet shaderManager;\r\nconst gl = renderer.getGLRenderContext();\r\nloader = new _engine_loader__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"./shader/\");\r\nloader.load([\"terrain.vert\", \"terrain.frag\"]);\r\nloader.setOnRendy(init);\r\nfunction init() {\r\n    renderer = new _engine_renderer__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer();\r\n    // 资源管理相关\r\n    shaderManager = new _engine_shader__WEBPACK_IMPORTED_MODULE_5__.ShaderManager(loader.resources, gl);\r\n    const terrainShader = shaderManager.get(\"terrain\");\r\n    camera = new _engine_scene__WEBPACK_IMPORTED_MODULE_0__.Camera();\r\n    camera.position = new Float32Array([0, 0, 0]);\r\n    const moutainVBO = new _engine_glUtils__WEBPACK_IMPORTED_MODULE_3__.VertexBufferObject(_engine_mesh__WEBPACK_IMPORTED_MODULE_1__[\"default\"].screen_quad(), gl);\r\n    mesh = new _engine_scene__WEBPACK_IMPORTED_MODULE_0__.SimpleMesh({ position: moutainVBO });\r\n    material = new _engine_scene__WEBPACK_IMPORTED_MODULE_0__.Material(terrainShader, {}, [mesh]);\r\n    scene = new _engine_scene__WEBPACK_IMPORTED_MODULE_0__.Graph();\r\n    scene.append(material);\r\n    renderer.setAnimationLoop(animation);\r\n    renderer.start();\r\n    document.body.appendChild(renderer.domElement);\r\n    (0,_engine_glUtils__WEBPACK_IMPORTED_MODULE_3__.setCanvasFullScreen)(renderer.domElement, scene);\r\n}\r\nfunction animation(time) {\r\n    renderer.render(scene, camera);\r\n}\r\n\n\n//# sourceURL=webpack://perlinnoise_water/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;